
/*********************************************************************
  SMA-Q2 / SMA-TIME Firmware v0.1
  You can program the SMA-Q2 via the Arduino IDE easily by installing the Adafruit nrf52 core,
  which also contains an older version of the nrfutil (0.5.2 in the case of core version 0.8.5).
  
  This raw sketch demonstrates some basic functions of the watch hardware such as ultra low power mode of the nrf52832, 
  the RTC, the display library, battery voltage measurement,
  basic BLE peripheral functionality, watchdog feeding, backlight etc...
  The accelerometer and heart rate sensor are not working yet.
 
  See https://hackaday.io/project/85463-color-open-source-smartwatch for pinout
    
  Change the pins in variant.h 
  (C:\Users\[....]\AppData\Local\Arduino15\packages\adafruit\hardware\nrf52\0.8.5\variants\feather52) file accordingly 
  (SPI depicted only)
  
  #define PIN_SPI_MISO         (11) //14
  #define PIN_SPI_MOSI         (3) //13
  #define PIN_SPI_SCK          (2) //12

  
  With the following nrfutil commands you can generate the .zip files for OTA DFU from
  .hex files the Arduino IDE produces if you go to "Sketch->Export compiled binary"
  (I'm working under windows):
  C:\Users\[.....]\AppData\Local\Arduino15\packages\adafruit\hardware\nrf52\0.8.5\tools\nrfutil-0.5.2\binaries\win32\nrfutil
  dfu genpkg --application C:\Users\[.....]\Documents\Arduino\\SMAQ2_FW1\SMAQ2_FW1.ino.feather52.hex
  --sd-req 0x88 C:\Users\[.....]\Documents\Arduino\SMAQ2_FW1\SMAQ2_FW1.zip

  The --sd-req 0x88 stands for s132 2.0.1 on nRF52
  0.8.5 is supposed to be the last core version supporting 2.0.1 softdevice.
  
  Once in DFU mode the .zip file generated by nrfutil can be fed into the DFU tool of the "nRF Toolbox" Android app to program the device over the air.


  With the original firmware, you enter the DFU mode of the watch by pressing the "back" as well as the "up"
  and "down" buttons simultaneously (a little acrobatic) when the watch powered off.
  Alternatively press this button combo and reset the thing (by pulling the rst testpad (P0.21) to ground with a reed switch) or power-cycling it.
  You should see a "DFU mode" screen with a progress bar.
  
  With custom firmware the MCU also checks for the bootloader button combo as it gets out of systemOff(BTN_UP, LOW); //name any pin and wakeup logic here 
   So in the above example you press up and down first, and the BTN_UP last to enter DFU mode. 
   
  A. Jordan 2018.
*********************************************************************/


#include <Adafruit_GFX.h>
#include <ColorMemLCD.h>
#include <RTCInt.h>
//#include <KX022.h>
#include <Wire.h>
#include <bluefruit.h>
//#include <RohmMultiSensor.h>

// any pins can be used
#define SCK 2
#define MOSI 3
#define SS 5
#define EXTCOMIN 6
#define DISP 7

#define VBAT 4 //with a 1/4 divider

#define VIBRO 30
#define BCKLT 8

#define BTN_BCK 9
#define BTN_UP 27
#define BTN_OK 28
#define BTN_DOWN 29

#define FLASH_MISO 11
#define FLASH_MOSI 13
#define FLASH_CS 12
#define FLASH_CLK 14

#define ACCEL_PWR 16
#define ACCEL_INT 15
#define ACCEL_SDA 17
#define ACCEL_SCL 18

#define HRM_SDA 19
#define HRM_SCL 20
#define HRM_INT 22
#define HRM_RST 10
#define HRM_PWR 31

#define CHG_STAT 23
#define CHG_PGOOD 24

#define UART_RXD 25
#define UART_TXD 26

// BLE Service
BLEDis  bledis;
BLEUart bleuart;
BLEBas  blebas;

//create instance of the ColorMemLCD class
ColorMemLCD display(SCK, MOSI, SS, EXTCOMIN);
SoftwareTimer timerDisp;
RTCInt rtc;  //create an RTCInt type object
//KX022<TwoWire> acc(Wire); // TwoWire is the default class, so this is the same as above
//KX022 acc(acc);
// instantiate the sensor's class with default settings
//KX022_1020 sensorAcc;
// the above is equivalent to
// KX022_1020 acc(INT_NONE);

//vars
float xyz[3];
int adcvalue = 0;
float mv_per_lsb = 3000.0F / 4096.0F; // 12-bit ADC with 3.6V input range
long buttonTimer = 0;
const int longPressTime = 3000;


boolean buttonActive = false;
boolean longPressActive = false;

void setup(void)
{
  //************************************************************************
  Serial.begin(9600);
  Serial.println("Hello!");
  //************************************************************************
  // Setup the BLE LED to be enabled on CONNECT
  // Note: This is actually the default behaviour, but provided
  // here in case you want to control this LED manually via PIN 19
  //Bluefruit.autoConnLed(true);

  // Config the peripheral connection with maximum bandwidth
  // more SRAM required by SoftDevice
  // Note: All config***() function must be called before begin()
  Bluefruit.configPrphBandwidth(BANDWIDTH_MAX);

  Bluefruit.begin();
  // Set max power. Accepted values are: -40, -30, -20, -16, -12, -8, -4, 0, 4
  Bluefruit.setTxPower(4);
  Bluefruit.setName("hacked SMA-Q2");
  //Bluefruit.setName(getMcuUniqueID()); // useful testing with multiple central connections
  Bluefruit.setConnectCallback(connect_callback);
  Bluefruit.setDisconnectCallback(disconnect_callback);

  // Configure and Start Device Information Service
  bledis.setManufacturer("Kauz");
  bledis.setModel("hacked SMA-Q2");
  bledis.begin();

  // Configure and Start BLE Uart Service
  bleuart.begin();

  // Start BLE Battery Service
  blebas.begin();
  blebas.write(100);

  // Set up and start advertising
  startAdv();
  //************************************************************************
  // Set the analog reference to 3.0V (default = 3.6V)
  analogReference(AR_INTERNAL_3_0);
  // Set the resolution to 12-bit (0..4095)
  analogReadResolution(12); // Can be 8, 10, 12 or 14
  //************************************************************************
  pinMode(BCKLT, OUTPUT);
  pinMode(VIBRO, OUTPUT);
  pinMode(ACCEL_PWR, OUTPUT);

  pinMode(BTN_BCK, INPUT_PULLUP);
  pinMode(BTN_UP, INPUT_PULLUP);
  pinMode(BTN_OK, INPUT_PULLUP);
  pinMode(BTN_DOWN, INPUT_PULLUP);


  attachInterrupt(BTN_UP, btn_up_isr, FALLING);

  pinMode(DISP, OUTPUT);

  digitalWrite(DISP, HIGH);
  digitalWrite(BCKLT, LOW);
  digitalWrite(VIBRO, LOW);
  digitalWrite(ACCEL_PWR, HIGH); //turn on the accelerometer
  //************************************************************************
  // begin the TWI (I2C) interface.
  // this function has to be called before any calls to .init()!
  //  Wire.begin();
  // initialize KX022-1020 with the default values
  //  sensorAcc.init();
  // start & clear the display
  display.begin();
  display.clearDisplay();
  //setup a software timer that will feed the watchdog every 9 seconds
  timerDisp.begin(1000, disp_callback);
  timerDisp.start();
  //acc.init();
  rtc.begin(TIME_H12); //init RTC in 12 hour mode
  //
  //filling internal structure for time
  rtc.time.hour = 10;          //hour
  rtc.time.minute = 44;       //minute
  rtc.time.second = 0;        //second
  rtc.time.Tmode = ANTI_MERIDIAN;

  //filling internal structure for date
  rtc.date.day = 13;        //day
  rtc.date.month = 8;       //month
  rtc.date.year = 15;       //year

  rtc.setTime();  //setting time
  rtc.setDate();  //setting date
  //************************************************************************
  // text display tests
  display.setTextSize(1);
  display.setTextColor(LCD_COLOR_MAGENTA);
  display.setCursor(0, 0);
  display.println("MAGENTA");
  display.setTextColor(LCD_COLOR_YELLOW);
  display.print("YELLOW"); 
  display.setTextColor(LCD_COLOR_CYAN);
  display.println("CYAN");
  display.setTextColor(LCD_COLOR_GREEN);
  display.println("GREEN");
  display.setTextColor(LCD_COLOR_RED);
  display.println("RED");
  display.setTextColor(LCD_COLOR_BLUE);
  display.println("BLUE");
  
  display.setTextColor(LCD_COLOR_WHITE, LCD_COLOR_BLACK); // 'inverted' text
  adcvalue = analogRead(VBAT);
  display.println(((float)adcvalue * mv_per_lsb * 4.0) / 1000.0); //1/4 resistor divider
  display.refresh();
  //delay(2000);
  wdt_feed();
  //************************************************************************

}

void loop(void)
{
  // Screen must be refreshed at least once per second
  //acc.getAccelXYZ(xyz);
  // measure the sensor values
  // sensorAcc.measure();
  // Get a fresh ADC value
  adcvalue = analogRead(VBAT);
  //delete what has been written
  rtc.getDate();      //getting date in local structure (local_date)
  rtc.getTime();      //getting time in local structure(local_time)

  display.setCursor(110, 16);
  display.setTextSize(1);
  display.setTextColor(LCD_COLOR_BLUE, LCD_COLOR_WHITE);
  display.print(rtc.time.second);  //second
  display.print(" ");

  display.setCursor(110, 0);
  display.setTextSize(1);
  display.setTextColor(LCD_COLOR_BLUE, LCD_COLOR_WHITE);
  display.print(((float)adcvalue * mv_per_lsb * 4.0) / 1000.0); //1/4 resistor divider
  display.print("V");
  display.refresh();

  display.setCursor(110, 32);
  display.setTextSize(1);
  display.setTextColor(LCD_COLOR_BLUE, LCD_COLOR_WHITE);
  display.setCursor(110, 32);
  //display.print((float)acc.getAccel(0));
  //display.print(sensorAcc.accelX);
  display.setCursor(110, 48);
  //display.print((float)acc.getAccel(1));
  //display.print(sensorAcc.accelY);
  display.setCursor(110, 64);
  //display.print((float)acc.getAccel(2));
  //display.print(sensorAcc.accelZ);
  display.print("   ");
  display.refresh();

  //just print last character for test purposes 
  while ( bleuart.available() )
  {
    uint8_t ch;
    ch =  bleuart.read();
    display.setTextSize(1);
    display.setTextColor(LCD_COLOR_BLUE, LCD_COLOR_WHITE);
    display.setCursor(0, 90);
    display.print(ch);
  }

  if (digitalRead(BTN_OK) == LOW) {
    // Request CPU to enter low-power mode until an event/interrupt occurs
	////C:\Users\[...]\AppData\Local\Arduino15\packages\adafruit\hardware\nrf52\0.8.5\cores\nRF5\wiring.c
    waitForEvent(); //not really useful yet
  }

  delay(50);
  readBckBtn(); //keep this in your main loop
  wdt_feed(); //keep this in your main loop to reset automatically after 10s if you screw up

}

// reload the watchdog timer that has been started by the bootloader and set for 10 seconds
void wdt_feed() {
  NRF_WDT->RR[0] = WDT_RR_RR_Reload;
}

//timer callback for toggling EXTCOMIN. 
//TO DO: we have to find a way to keep toggling this pin even in low 
//power modes if we want to always keep the display on...
void disp_callback(TimerHandle_t handle) {

  (void) handle;
  digitalToggle(EXTCOMIN);

}

void btn_up_isr() {
  //do something
}

//implements long press for power off and short press for backlight toggle
void readBckBtn() {

  if (digitalRead(BTN_BCK) == LOW) {
    if (buttonActive == false) {
      buttonActive = true;
      buttonTimer = millis();
    }
    if ((millis() - buttonTimer > longPressTime) && (longPressActive == false)) {
      longPressActive = true;
      //button has been pressed for a long time
		//set any pin and wakeup logic here.
      systemOff(BTN_UP, LOW); //implemented here:
								//C:\Users\[...]\AppData\Local\Arduino15\packages\adafruit\hardware\nrf52\0.8.5\cores\nRF5\wiring.c
    }
  } else {
    if (buttonActive == true) {
      if (longPressActive == true) {
        longPressActive = false;
      } else {
        //button has been pressed for a short time
        digitalToggle(BCKLT);


      }
      buttonActive = false;
    }
  }
}

void disconnect_callback(uint16_t conn_handle, uint8_t reason)
{
  (void) conn_handle;
  (void) reason;

  display.setTextSize(1);
  display.setTextColor(LCD_COLOR_BLUE, LCD_COLOR_WHITE);
  display.setCursor(110, 100);
  display.print("disconn ");
}

void startAdv(void)
{
  // Advertising packet
  Bluefruit.Advertising.addFlags(BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE);
  Bluefruit.Advertising.addTxPower();

  // Include bleuart 128-bit uuid
  Bluefruit.Advertising.addService(bleuart);

  // Secondary Scan Response packet (optional)
  // Since there is no room for 'Name' in Advertising packet
  Bluefruit.ScanResponse.addName();

  /* Start Advertising
     - Enable auto advertising if disconnected
     - Interval:  fast mode = 20 ms, slow mode = 152.5 ms
     - Timeout for fast mode is 30 seconds
     - Start(timeout) with timeout = 0 will advertise forever (until connected)

     For recommended advertising interval
     https://developer.apple.com/library/content/qa/qa1931/_index.html
  */
  Bluefruit.Advertising.restartOnDisconnect(true);
  Bluefruit.Advertising.setInterval(32, 244);    // in unit of 0.625 ms
  Bluefruit.Advertising.setFastTimeout(30);      // number of seconds in fast mode
  Bluefruit.Advertising.start(0);                // 0 = Don't stop advertising after n seconds
}

void connect_callback(uint16_t conn_handle)
{
  char central_name[32] = { 0 };
  Bluefruit.Gap.getPeerName(conn_handle, central_name, sizeof(central_name));


  display.setTextSize(1);
  display.setTextColor(LCD_COLOR_BLUE, LCD_COLOR_WHITE);
  display.setCursor(110, 100);
  display.print("conn   ");
}
/**
   RTOS Idle callback is automatically invoked by FreeRTOS
   when there are no active threads. E.g when loop() calls delay() and
   there is no bluetooth or hw event. This is the ideal place to handle
   background data.

   NOTE: FreeRTOS is configured as tickless idle mode. After this callback
   is executed, if there is time, freeRTOS kernel will go into low power mode.
   Therefore waitForEvent() should not be called in this callback.
   http://www.freertos.org/low-power-tickless-rtos.html

   WARNING: This function MUST NOT call any blocking FreeRTOS API
   such as delay(), xSemaphoreTake() etc ... for more information
   http://www.freertos.org/a00016.html
*/
void rtos_idle_callback(void)
{
  // Don't call any other FreeRTOS blocking API()
  // Perform background task(s) here
}

